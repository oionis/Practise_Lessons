Многопоточность

Что бы реализовать многопоточность, необходимо переопределить метод run().
Это можно сделать 2мя способами:

1. Создать класс ("MyThread") который наследует класс Thread, и переопределить метод run()
Что бы запустить поток: нужно запустить метод start() на объекте класса (new MyThread().start())
И уже метод start() запустит метод run().

2. Создать класс ("MyRunnable") который имплементирует интерфейс Runnable, и так же переопределить метод run().
Что бы запустить поток: нужно создать экземпляр класса Thread, в аргументы конструктора передать экзепляр нашего класса ( new Thread(new MyRunnable()).start() )
И запустить метод start().

В методе run() пишеться код который следует выполнить в новом потоке.
Каждый поток имеет свой стек вызовов, который начинается с метода run().

-----

Таким образом будут создаваться новые потоки. По умолчанию, основным потоком является поток main (это основной поток). А создавая новые потоки, мы получаем Thread-0, 1, 2 и тд.
Каждый раз, при создании потока, мы добавляем его в pool (басейн) потоков. Где все потоки находятся в хаотическом порядке.
То есть, изначально, потоки не имеют чёткой последовательности того, в каком порядке следует выполнятся.

-----

Важно помнить, что потоки создаются именно в момент запуска метода start(). Если запустить просто метод run(), то он запустится в потоке main.

Ещё одним важным нюансом будет то, что один и тот же поток следует запускать только 1 раз.
Если один и тот же поток вызвать повторно на одном и том же объекте, новый поток убъет выполнение старого потока. А так же выскочит исключение IllegalThreadStateException
Что бы создать N-ное потоков одного класса, следует создать N-ное количество экземпляров этого класса, и у каждого экземпляра, запустить метод start().

-----

Жизненный цикл потоков.

New -> Runnable <-> Running -> Dead
         Waiting/
         block/
         sleep

1. Ка только вызывается метод start(), поток переходит в состояние New
2. После этого, поток добавляется в pool потоков и переходит в состояние Runnable
Все потоки которые ожидают своей очереди на выполнение, находятся в этом статусе.
При этом в JVM создается, так сказать, своё расписание для запуска потоков.
3. Когда по расписанию, до потока прийдёт очередь выполнятся, он перейдёт в состояние Running, и запустит метод run().
Но, в любой момент, когда JVM посчитает что нужно запустить другой поток, этот поток вернётся обратно в состояние Runnable и он снова будет ожидать своей очереди.
Таким образом, потоки могут прыгать из состояния Runnable в Running и наоборот.
4. И когда уже поток полностью завершил выполнение своей задачи, он завершается, и получает статус Dead.

5. Так же, во время выполнения операций, потоки могут переходить в состояния Waiting/ block/ sleep
После выхода с этих блоков, поток получает состояние Runnable.


Методы sleep(), yield(), join()

 - Sleep - вызывается в текущем классе, у класса Thread. "Усыпляет" выполнение метода на определённое количество милисекунд.
После того как сон закончился, поток переходит в состояние Runnable.
Так же, Sleep неоьходимо помещать в блок try{} catch{}

 - Yield (уступать) - вызывается так же в текущем классе, у класса Thread.
Текущий поток, переводит из состояния Running в Runnable, тем самым, может уступить место другим потокам.
Но так же, может получится так, что поток в котором был вызван метод Yield, снова будет запущен.

 - Join - вызывается от экземпляра класса.
Таким образом, класс внутри которого запустился этот метод переходит в состояние Runnable, а объект на котором был вызван метод - запускается (статус Running).
И главный поток (внутри которого был вызван метод) прекращает своё выполнение до тех пор, пока не завершиться другой поток (на котором был вызван метод).